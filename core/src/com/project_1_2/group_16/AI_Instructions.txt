please put a paramater for an App.java object in the constructor

to shoot the ball, use app.shoot(vX, vY) (where app = an instance of App.java)

golfball position: app.getGolfball().getPosition()
hole position: Input.VT

sandpits: Terrain.sandpits
trees: Terrain.trees
height profile: Terrain.getHeight(x, y)

App.allowHit tells you if the ball is still moving or is at a stop

Use Vector3 / Vector2 classes to avoid accessive memory usage
Use multithreading if you know how to

---------------------------------------------------------------------------
                                NEW PHYSICS ENGINE:
The new physics engine is STATE VECTOR ORIENTATED (it uses solely state vectors for its calculations)
STATE VECTORS are objects used to represent the motion of a golfball
To do simulations with this new physics engine:
    - Create a Game object
    - do game.setNumericalSolver(); with either Solver.EULER, Solver.RK2, or Solver.RK4 as paramater
    - to simulate the shot of an imaginary golfball, do game.run(sv, null);
        (where sv represents the state vector of the imaginary golfball)
    - run this in a loop until sv.stop == true
    - you can access the final coordinates using sv.x and sv.y

-----------------------------------A* Pathfinding IDEA---------------------
1- The idea is essentially to find the shortest set of velocity pairs (Velocity X and Velocity Y)
2- For this we will use A* Pathfinding with node objects having two fields :-
--- Field 1 : List of velocity pairs (Vector2) when applied to the ball from the starting position will end up in the position stated in field 2
--- Field 2 : Ball position (coordinates in float array) when Field 1 (list of velocity pairs) is applied to the ball from starting position
3- Every A* Pathfinding algorithm has a g function and an h function, in our case the g function can be the size of the list of Field 1
(basically the number of hits applied to the ball if this path is taken) and the h function can be the fitness of the ending position
of the ball if the list of velocity pairs is applied to the ball from the starting position (fitness = results from floodfill array),
so as the node object we create have these 2 fields we can directly get the f value of the node directly from the object (cool huh?)
4- To generate the neighbours of the current node we can use an optimization algorithm such as a Particle Swarm Optimization and selecting
the fittest individuals
5- Once we have these ideas, we can basically just apply the A* Pathfinding directly from pseudo-code and we can find the shortest
set of velocity pairs (hits) needed to score